# picoGym Level 188: Mini RSA
Source: https://play.picoctf.org/practice/challenge/188

## Goal
What happens if you have a small exponent?<br>
There is a twist though, we padded the plaintext so that (M ** e) is just barely larger than N<br>
Let's decrypt this: ciphertext<br>
https://mercury.picoctf.net/static/e7e63a387acc347648918f419d1ae438/ciphertext

## What I learned
```
p, q        → Two large prime numbers used to generate keys  
N           → Modulus: N = p × q  
×           → Multiplication symbol  
ϕ(N)        → Euler’s Totient Function: ϕ(N) = (p−1)(q−1)  
≡           → Modular Congruence (e.g., a ≡ b mod m means a and b leave the same remainder when divided by m)  
mod         → Modulo operation: returns the remainder after division  
M           → Plaintext Message (original message)  
C           → Ciphertext (encrypted message)  
e           → Public exponent (part of the public key)  
d           → Private exponent (part of the private key)  
^           → Exponentiation (power operation, M^e)

RSA is built on 3 key concepts:
    Modular Exponentiation
    Euler’s Theorem and Trapdoor One-Way Function
    Modular Inverse

Write Up explains RSA Math: https://medium.com/@routbiswajit70681/picoctf-write-up-minirsa-e51bf43536fd

d ended up as None means modular inverse function failed, probably because e and φ(n) are not coprime (gcd(e, φ(n)) ≠ 1)
Wiener’s attack only works if the RSA private exponent d is “small”

n = huge

Low-exponent attack
    m is small enough don’t need d
    compute the integer cube root of c

M**3 mod n = c rewrite M**3 = i*n + c
    some value of i 
    M = iroot(i*n+c, 3)             # use iroot function from gmpy2 module

c = m^e % n where m is the plaintext. E is small, so we could conceivably compute cube root
```

## Side Quest
```
RSActfTool: https://github.com/RsaCtfTool/RsaCtfTool
$ python RsaCtfTool.py -e 3 -n TODO --uncipher TODO ⌨️

c = 1220012318588871886132524757898884422174534558055593713309088304910273991073554732659977133980685370899257850121970812405700793710546674062154237544840177616746805668666317481140872605653768484867292138139949076102907399831998827567645230986345455915692863094364797526497302082734955903755050638155202890599808147276605782889813772992918898400408026067642464141885067379614918437023839625205930332182990301333585691581437573708925507991608699550931884734959475780164693178925308303420298715231388421829397209435815583140323329070684583974607064056215836529244330562254568162453025117819569708767522400676415959028292550922595255396203239357606521218664984826377129270592358124859832816717406984802489441913267065210674087743685058164539822623810831754845900660230416950321563523723959232766094292905543274107712867486590646161628402198049221567774173578088527367084843924843266361134842269034459560612360763383547251378793641304151038512392821572406034926965112582374825926358165795831789031647600129008730

def find_cubic_root(n):
    a = 1
    b = n
    while b - a > 1:
        mid = (a + b) // 2
        if mid**3 > n:
            b = mid
        else:
            a = mid

    if a ** 3 == n:
        return a
    elif b ** 3 == n:
        return b
    else:
        return 0

m = find_cubic_root(c)
h = hex(m)
print(h)
p = str(hex(m)[2:]).decode('hex')
print(p)
```

## Solution
```
https://webshell.picoctf.org/

AsianHacker-picoctf@webshell:~$ cd /tmp/ ⌨️
AsianHacker-picoctf@webshell:/tmp$ wget https://mercury.picoctf.net/static/e7e63a387acc347648918f419d1ae438/ciphertext ⌨️
--2025-09-11 08:32:30--  https://mercury.picoctf.net/static/e7e63a387acc347648918f419d1ae438/ciphertext
Resolving mercury.picoctf.net (mercury.picoctf.net)... 18.189.209.142
Connecting to mercury.picoctf.net (mercury.picoctf.net)|18.189.209.142|:443... connected.
HTTP request sent, awaiting response... 200 OK
Length: 2039 (2.0K) [application/octet-stream]
Saving to: 'ciphertext'

ciphertext                                                 100%[======================================================================================================================================>]   1.99K  --.-KB/s    in 0s      

2025-09-11 08:32:30 (1.56 GB/s) - 'ciphertext' saved [2039/2039]

AsianHacker-picoctf@webshell:/tmp$ file ciphertext 
ciphertext: ASCII text, with very long lines (1022)
AsianHacker-picoctf@webshell:/tmp$ cat ciphertext ⌨️
N: 1615765684321463054078226051959887884233678317734892901740763321135213636796075462401950274602405095138589898087428337758445013281488966866073355710771864671726991918706558071231266976427184673800225254531695928541272546385146495736420261815693810544589811104967829354461491178200126099661909654163542661541699404839644035177445092988952614918424317082380174383819025585076206641993479326576180793544321194357018916215113009742654408597083724508169216182008449693917227497813165444372201517541788989925461711067825681947947471001390843774746442699739386923285801022685451221261010798837646928092277556198145662924691803032880040492762442561497760689933601781401617086600593482127465655390841361154025890679757514060456103104199255917164678161972735858939464790960448345988941481499050248673128656508055285037090026439683847266536283160142071643015434813473463469733112182328678706702116054036618277506997666534567846763938692335069955755244438415377933440029498378955355877502743215305768814857864433151287
e: 3

ciphertext (c): 1220012318588871886132524757898884422174534558055593713309088304910273991073554732659977133980685370899257850121970812405700793710546674062154237544840177616746805668666317481140872605653768484867292138139949076102907399831998827567645230986345455915692863094364797526497302082734955903755050638155202890599808147276605782889813772992918898400408026067642464141885067379614918437023839625205930332182990301333585691581437573708925507991608699550931884734959475780164693178925308303420298715231388421829397209435815583140323329070684583974607064056215836529244330562254568162453025117819569708767522400676415959028292550922595255396203239357606521218664984826377129270592358124859832816717406984802489441913267065210674087743685058164539822623810831754845900660230416950321563523723959232766094292905543274107712867486590646161628402198049221567774173578088527367084843924843266361134842269034459560612360763383547251378793641304151038512392821572406034926965112582374825926358165795831789031647600129008730

https://www.dcode.fr/rsa-cipher
✘Wiener's attack: failure
✘(Self-Limited) Prime Factors Decomposition: failure
✘FactorDB database: failure

Method 1: gmpy2 library
AsianHacker-picoctf@webshell:/tmp$ man gmpy2 ⌨️
INTRODUCTION TO GMPY2
       gmpy2  is  a  C-coded  Python extension module that supports multiple-precision arithmetic. gmpy2 is the successor to the original gmpy module. The gmpy module only supported the GMP multiple-precision library. gmpy2 adds
       support for the MPFR (correctly rounded real floating-point arithmetic) and MPC (correctly rounded complex floating-point arithmetic) libraries. gmpy2 also updates the API and naming conventions to be more consistent  and
       support the additional functionality.
AsianHacker-picoctf@webshell:/tmp$ vi pythonScript.py ⌨️ 
AsianHacker-picoctf@webshell:/tmp$ cat pythonScript.py ⌨️
#!/usr/bin/env python3
import gmpy2

def main() -> None:
    # Given RSA parameters
    N = 1615765684321463054078226051959887884233678317734892901740763321135213636796075462401950274602405095138589898087428337758445013281488966866073355710771864671726991918706558071231266976427184673800225254531695928541272546385146495736420261815693810544589811104967829354461491178200126099661909654163542661541699404839644035177445092988952614918424317082380174383819025585076206641993479326576180793544321194357018916215113009742654408597083724508169216182008449693917227497813165444372201517541788989925461711067825681947947471001390843774746442699739386923285801022685451221261010798837646928092277556198145662924691803032880040492762442561497760689933601781401617086600593482127465655390841361154025890679757514060456103104199255917164678161972735858939464790960448345988941481499050248673128656508055285037090026439683847266536283160142071643015434813473463469733112182328678706702116054036618277506997666534567846763938692335069955755244438415377933440029498378955355877502743215305768814857864433151287
    e = 3  # low public exponent
    c = 1220012318588871886132524757898884422174534558055593713309088304910273991073554732659977133980685370899257850121970812405700793710546674062154237544840177616746805668666317481140872605653768484867292138139949076102907399831998827567645230986345455915692863094364797526497302082734955903755050638155202890599808147276605782889813772992918898400408026067642464141885067379614918437023839625205930332182990301333585691581437573708925507991608699550931884734959475780164693178925308303420298715231388421829397209435815583140323329070684583974607064056215836529244330562254568162453025117819569708767522400676415959028292550922595255396203239357606521218664984826377129270592358124859832816717406984802489441913267065210674087743685058164539822623810831754845900660230416950321563523723959232766094292905543274107712867486590646161628402198049221567774173578088527367084843924843266361134842269034459560612360763383547251378793641304151038512392821572406034926965112582374825926358165795831789031647600129008730

    # -------------------------------
    # Why this loop works:
    # -------------------------------
    # In normal low-exponent RSA attacks, we assume that the plaintext m is smaller than N^(1/e)
    # so that c = m^e < N, and taking the integer cube root directly recovers m.
    # In our previous scripts, we tried exactly that:
    #     m_root = gmpy2.iroot(c, e)
    # But here, m^3 > N (the plaintext is bigger than modulus for the cube attack), 
    # so a direct cube root fails.
    #
    # The trick used here is called "shifted cube root attack" or "Franklin-Reiter related message attack":
    # Since c = m^3 mod N, the real plaintext m might be larger than N^(1/3).
    # If we consider m + k*N for some small integer k, then (m + k*N)^3 mod N == c
    # (mod N arithmetic cancels the N multiples), allowing us to find m exactly.
    #
    # So we loop over i = 0..9999 trying m_candidate = i*N + c
    # and take the integer cube root. If it is an exact cube, then we found the plaintext.
    # This works when plaintext is slightly larger than N^(1/3), which explains why
    # previous direct cube-root approaches failed.
    # -------------------------------

    for i in range(10000):
        # Try m_candidate = i*N + c
        m, is_true_root = gmpy2.iroot(i * N + c, e)
        if is_true_root:  # Found perfect cube
            print(f"Found i = {i}")
            # Convert integer to bytes and decode
            hex_m = format(m, 'x')
            if len(hex_m) % 2:
                hex_m = '0' + hex_m
            plaintext = bytearray.fromhex(hex_m).decode(errors='ignore')
            print(f"Message: {plaintext}")
            break

if __name__ == "__main__":
    main()
AsianHacker-picoctf@webshell:/tmp$ chmod +x pythonScript.py ⌨️ 
AsianHacker-picoctf@webshell:/tmp$ ./pythonScript.py ⌨️
Found i = 3533
Message:                                         picoCTF{e_sh0u1d_b3_lArg3r_85d643d5} 🔐

Method 1: iroot: https://pypi.org/project/gmpy2/
AsianHacker-picoctf@webshell:/tmp$ vi pythonScript.py ⌨️ 
AsianHacker-picoctf@webshell:/tmp$ cat pythonScript.py ⌨️
#!/usr/bin/python

from gmpy2 import iroot ❤️❤️❤️

def main() -> None:
    N = 1615765684321463054078226051959887884233678317734892901740763321135213636796075462401950274602405095138589898087428337758445013281488966866073355710771864671726991918706558071231266976427184673800225254531695928541272546385146495736420261815693810544589811104967829354461491178200126099661909654163542661541699404839644035177445092988952614918424317082380174383819025585076206641993479326576180793544321194357018916215113009742654408597083724508169216182008449693917227497813165444372201517541788989925461711067825681947947471001390843774746442699739386923285801022685451221261010798837646928092277556198145662924691803032880040492762442561497760689933601781401617086600593482127465655390841361154025890679757514060456103104199255917164678161972735858939464790960448345988941481499050248673128656508055285037090026439683847266536283160142071643015434813473463469733112182328678706702116054036618277506997666534567846763938692335069955755244438415377933440029498378955355877502743215305768814857864433151287
    e = 3
    c = 1220012318588871886132524757898884422174534558055593713309088304910273991073554732659977133980685370899257850121970812405700793710546674062154237544840177616746805668666317481140872605653768484867292138139949076102907399831998827567645230986345455915692863094364797526497302082734955903755050638155202890599808147276605782889813772992918898400408026067642464141885067379614918437023839625205930332182990301333585691581437573708925507991608699550931884734959475780164693178925308303420298715231388421829397209435815583140323329070684583974607064056215836529244330562254568162453025117819569708767522400676415959028292550922595255396203239357606521218664984826377129270592358124859832816717406984802489441913267065210674087743685058164539822623810831754845900660230416950321563523723959232766094292905543274107712867486590646161628402198049221567774173578088527367084843924843266361134842269034459560612360763383547251378793641304151038512392821572406034926965112582374825926358165795831789031647600129008730

    for i in range(5000):
        m, exact_root = iroot(i*N + c, e)
        if exact_root:
            print(f"Found i: {i}")
            msg = bytes.fromhex(format(m, 'x')).decode()
            print(f"Found Msg: {msg}")
            break

if __name__ == "__main__":
    main()
AsianHacker-picoctf@webshell:/tmp$ chmod +x pythonScript.py ⌨️
AsianHacker-picoctf@webshell:/tmp$ ./pythonScript.py ⌨️
Found i: 3533
Found Msg:                                                   picoCTF{e_sh0u1d_b3_lArg3r_85d643d5} 🔐

# Method 2:
AsianHacker-picoctf@webshell:/tmp$ pip3 install --user tqdm ⌨️
Collecting tqdm
  Downloading tqdm-4.67.1-py3-none-any.whl.metadata (57 kB)
Downloading tqdm-4.67.1-py3-none-any.whl (78 kB)
WARNING: Error parsing dependencies of send2trash: Expected matching RIGHT_PARENTHESIS for LEFT_PARENTHESIS, after version specifier
    sys-platform (=="darwin") ; extra == 'objc'
                 ~^
Installing collected packages: tqdm
  WARNING: The script tqdm is installed in '/home/AsianHacker-picoctf/.local/bin' which is not on PATH.
  Consider adding this directory to PATH or, if you prefer to suppress this warning, use --no-warn-script-location.
Successfully installed tqdm-4.67.1

[notice] A new release of pip is available: 25.0.1 -> 25.2
[notice] To update, run: python3 -m pip install --upgrade pip
AsianHacker-picoctf@webshell:/tmp$ cat pythonScript.py ⌨️
from decimal import * ❤️❤️❤️
from tqdm import tqdm ❤️❤️❤️❤️❤️

N = Decimal(1615765684321463054078226051959887884233678317734892901740763321135213636796075462401950274602405095138589898087428337758445013281488966866073355710771864671726991918706558071231266976427184673800225254531695928541272546385146495736420261815693810544589811104967829354461491178200126099661909654163542661541699404839644035177445092988952614918424317082380174383819025585076206641993479326576180793544321194357018916215113009742654408597083724508169216182008449693917227497813165444372201517541788989925461711067825681947947471001390843774746442699739386923285801022685451221261010798837646928092277556198145662924691803032880040492762442561497760689933601781401617086600593482127465655390841361154025890679757514060456103104199255917164678161972735858939464790960448345988941481499050248673128656508055285037090026439683847266536283160142071643015434813473463469733112182328678706702116054036618277506997666534567846763938692335069955755244438415377933440029498378955355877502743215305768814857864433151287)
e = Decimal(3)
c = Decimal(1220012318588871886132524757898884422174534558055593713309088304910273991073554732659977133980685370899257850121970812405700793710546674062154237544840177616746805668666317481140872605653768484867292138139949076102907399831998827567645230986345455915692863094364797526497302082734955903755050638155202890599808147276605782889813772992918898400408026067642464141885067379614918437023839625205930332182990301333585691581437573708925507991608699550931884734959475780164693178925308303420298715231388421829397209435815583140323329070684583974607064056215836529244330562254568162453025117819569708767522400676415959028292550922595255396203239357606521218664984826377129270592358124859832816717406984802489441913267065210674087743685058164539822623810831754845900660230416950321563523723959232766094292905543274107712867486590646161628402198049221567774173578088527367084843924843266361134842269034459560612360763383547251378793641304151038512392821572406034926965112582374825926358165795831789031647600129008730)

def int_to_ascii(m):
    m_hex = hex(int(m))[2:-1]                                                           # Number to hex
    m_ascii = "".join(chr(int(m_hex[i : i + 2], 16)) for i in range(0, len(m_hex), 2))  # Hex to Ascii
    return m_ascii

# Find padding
getcontext().prec = 280  # Increase precision
padding = 0

for k in tqdm(range(0, 10_000)):                            # tqdm makes progress bar “fill” while a loop runs
    m = pow(k * N + c, 1 / e)
    m_ascii = int_to_ascii(m)

    if "pico" in m_ascii:
        padding = k
        break

print("Padding: %s" % padding)

# Increase precision further to get entire flag
getcontext().prec = 700

m = pow(padding * N + c, 1 / e)
m_ascii = int_to_ascii(m)
print("Flag: %s" % m_ascii.strip())

AsianHacker-picoctf@webshell:/tmp$ python3 pythonScript.py ⌨️
 35%|███████████████████████████████████████████████████████████████████▍                                                                                                                           | 3533/10000 [00:23<00:42, 152.30it/s]
Padding: 3533
Flag: picoCTF{e_sh0u1d_b3_lArg3r_85d643d5 🔐

# Method 3: modifying another programmers code 
AsianHacker-picoctf@webshell:/tmp$ cat pythonScript.py ⌨️
import binascii ❤️❤️❤️

n = 1615765684321463054078226051959887884233678317734892901740763321135213636796075462401950274602405095138589898087428337758445013281488966866073355710771864671726991918706558071231266976427184673800225254531695928541272546385146495736420261815693810544589811104967829354461491178200126099661909654163542661541699404839644035177445092988952614918424317082380174383819025585076206641993479326576180793544321194357018916215113009742654408597083724508169216182008449693917227497813165444372201517541788989925461711067825681947947471001390843774746442699739386923285801022685451221261010798837646928092277556198145662924691803032880040492762442561497760689933601781401617086600593482127465655390841361154025890679757514060456103104199255917164678161972735858939464790960448345988941481499050248673128656508055285037090026439683847266536283160142071643015434813473463469733112182328678706702116054036618277506997666534567846763938692335069955755244438415377933440029498378955355877502743215305768814857864433151287
e = 3
c = 1220012318588871886132524757898884422174534558055593713309088304910273991073554732659977133980685370899257850121970812405700793710546674062154237544840177616746805668666317481140872605653768484867292138139949076102907399831998827567645230986345455915692863094364797526497302082734955903755050638155202890599808147276605782889813772992918898400408026067642464141885067379614918437023839625205930332182990301333585691581437573708925507991608699550931884734959475780164693178925308303420298715231388421829397209435815583140323329070684583974607064056215836529244330562254568162453025117819569708767522400676415959028292550922595255396203239357606521218664984826377129270592358124859832816717406984802489441913267065210674087743685058164539822623810831754845900660230416950321563523723959232766094292905543274107712867486590646161628402198049221567774173578088527367084843924843266361134842269034459560612360763383547251378793641304151038512392821572406034926965112582374825926358165795831789031647600129008730

# Source: https://riptutorial.com/python/example/8751/computing-large-integer-roots
def nth_root(x, n):
    # Start with some reasonable bounds around the nth root
    upper_bound = 1
    while upper_bound ** n <= x:
        upper_bound *= 2
    lower_bound = upper_bound // 2
    # Keep searching for a better result as long as the bounds make sense
    while lower_bound < upper_bound:
        mid = (lower_bound + upper_bound) // 2
        mid_nth = mid ** n
        if lower_bound < mid and mid_nth < x:
            lower_bound = mid
        elif upper_bound > mid and mid_nth > x:
            upper_bound = mid
        else:
            # Found perfect nth root
            return mid
    return mid + 1

# x = 2 ** 100
# cube = x ** 3
# root = nth_root(cube, 3)
# x == root
# True
for i in range(4000):
    st = ("{:x}".format(nth_root(c+i*n, 3)))
    if "7069636f" in st:            # "pico" in hex
        print(st)
        print(binascii.unhexlify(st))

AsianHacker-picoctf@webshell:/tmp$ python3 pythonScript.py ⌨️
20202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020207069636f4354467b655f7368307531645f62335f6c41726733725f38356436343364357d
b'                                                                 picoCTF{e_sh0u1d_b3_lArg3r_85d643d5}' 🔐
```

## Flag
picoCTF{e_sh0u1d_b3_lArg3r_85d643d5}

## Continue
[Continue](./picoGym0154.md)